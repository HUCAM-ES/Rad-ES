
import urllib.parse, urllib.request
import urllib, json
import threading, time, logging
import sys, getopt

from datetime import datetime

import AngioGet

local = True

if local:
    usernameV = 'hucam'
    passwordV = 'doseapp123'
else:
    usernameV = 'hucam'
    passwordV = 'doseapp123'

#usernameV = 'dicomcomm'
#passwordV = 'comunicatewithdicom123'
    
def parse_uid(uid_string):
    return json.loads(uid_string)

    
class Stack(object):
    def __init__(self):
        logging.debug('Lock initialized...')
        self.lock = threading.Lock()
        self.value = []
        
    def append_new(self, tasks):
        logging.debug('an'+str(tasks))
        self.lock.acquire()
        try:
            for task in tasks:
                in_var = False
                for obj in self.value:
                    if obj[:-1] == task[:-1]:
                        in_var = True
                if not in_var:
                    self.value.append(task)
        finally:
            self.lock.release()  
    
    def delete_old(self, tasks):
        logging.debug('do'+str(tasks))
        self.lock.acquire()
        try:
            in_var = False
            for obj in self.value:
                if obj[-1] == True:
                    for task in tasks:
                        if obj[:-1] == task[:-1]:
                            in_var = True
                    if not in_var:
                        self.value.remove(obj)
        finally:
            self.lock.release()  
    
    def sort_by_priority(self):
        logging.debug('sbp')
        self.lock.acquire()
        try:
            self.value.sort(key=(lambda x: x[2]), reverse=True)
        finally:
            self.lock.release() 
            
    def pop_by_priority(self):
        logging.debug('pbp'+ str(self.value))
        if len(self.value) != 0:
            last = []
            self.lock.acquire()
            try:
                for i in range(len(self.value)):
                    if self.value[i][-1] == False:
                        self.value[i][-1] = True
                        last = self.value[i]
                        break
                        
            finally:
                self.lock.release() 
                return last
        else:
            return None

            
class RepeatingTimer(object):

    def __init__(self, num_days_forward, hour_of_day, f, *args, **kwargs):
        logging.debug('Initialize timer...')
        self.num_days_forward = num_days_forward
        self.hour_of_day = hour_of_day
        self.f = f
        self.args = args
        self.kwargs = kwargs
        
        self.interval = self.period(num_days_forward, hour_of_day)
        self.timer = None

    def callback(self):
        logging.debug('Callback called...')
        logging.debug('Calling function...')
        self.f(*self.args, **self.kwargs)
        logging.debug('Creating new timer')
        self.start()

    def cancel(self):
        logging.debug('Cancel called...')
        self.timer.cancel()

    def start(self):
        logging.debug('Start of new timer...')
        self.interval = self.period(self.num_days_forward, self.hour_of_day)
        logging.debug('Timer set to '+str(self.interval)+' seconds...')
        self.timer = threading.Timer(self.interval, self.callback)
        self.timer.start()
        
    def period(self, num_days_forward, hour_of_day):
        time_today = datetime.today()
        #time_next = time_today.replace(day=time_today.day+num_days_forward, hour=hour_of_day, minute=0, second=0, microsecond=0)
        time_next = time_today.replace(day=time_today.day, hour=10, minute=59, second=0, microsecond=0)
        delta_t = time_next - time_today
        period = delta_t.seconds + 1
        return period
            
            
def get_csrf_token(url):
    response = urllib.request.urlopen(url)
    return response.info()['Set-Cookie'].split(';')[0].split('=')[1]
    
    
def login( base_address, username=None, password=None ):

    # prompt for the username (if needed), password
    if username == None:
        username = raw_input( 'Username: ' )
    if password == None:
        password = getpass.getpass( 'Password: ' )

    # fetch the login page in order to get the csrf token
    cookieHandler = urllib.request.HTTPCookieProcessor()
    opener = urllib.request.build_opener( urllib.request.HTTPSHandler(), cookieHandler )
    urllib.request.install_opener( opener )

    #login_url = base_address + PATH_TO_LOGIN
    login_page = opener.open( base_address )

    # attempt to get the csrf token from the cookie jar
    csrf_cookie = None
    for cookie in cookieHandler.cookiejar:
        if cookie.name == 'csrftoken':
             csrf_cookie = cookie
             break
    if not cookie:
        raise IOError( "No csrf cookie found" )

    # login using the usr, pwd, and csrf token
    login_data = urllib.parse.urlencode( dict(
        username=username, password=password,
        csrfmiddlewaretoken=csrf_cookie.value ) ).encode("utf-8")
    req = urllib.request.Request( base_address, login_data )
    response = urllib.request.urlopen( req )

    # should redirect to the welcome page here, if back at log in - refused
    if response.geturl() == base_address:
        raise IOError( 'Authentication refused' )

    # save the cookies/opener for further actions
    return opener

    
def worker_receive(st):
    while(1):
        if local:
            response = urllib.request.urlopen('http://127.0.0.1:8000/comm/out.json')
        else:
            response = urllib.request.urlopen('http://esthevaov.pythonanywhere.com/comm/out.json')
        
        response_data = response.read().decode('utf-8')
        json_obj = json.loads(response_data)
        
        
        task_list = json_obj['tasks_uid']
        for i in range(len(task_list)):
            task_list[i][0] = parse_uid(task_list[i][0])
        task_list = task_list + json_obj['tasks_name']
        task_list = task_list + json_obj['tasks_date_fixed']
        task_list = task_list + json_obj['tasks_date_period']
        
        logging.debug('got_rec: '+str(task_list))
        
        st.append_new(task_list)
        st.delete_old(task_list)
        st.sort_by_priority()
        time.sleep(1)


def worker_send(st):
    while(1):
        if local:
            csrf = get_csrf_token('http://127.0.0.1:8000/comm/in/')
        else:
            csrf = get_csrf_token('http://esthevaov.pythonanywhere.com/comm/in/')
        data = st.pop_by_priority()
        if (data != None) and (data != []):
            try:
                if data[-2] == 'date_fixed':
                    logging.debug('got_send date')
                    name_vector = AngioGet.name_get_by_date_fixed(data[0], '10.5.136.10', 4096, "projetoDoses", 'server-dicom', 'SR')                
                    json_data = {
                    'id': data[1],
                    'type': 'date_fixed',
                    'full_info': name_vector
                    } 
                    logging.debug('got_send: '+str(json_data))
                
                elif data[-2] == 'date_period':
                    logging.debug('got_send date')
                    #uid_vector = AngioGet.name_get_by_date_period(data[0], '10.5.136.10', 4096, "projetoDoses", 'server-dicom', 'SR')
                    uid_vector = AngioGet.name_get_by_date_period_fast(data[0], '10.5.136.10', 4096, "projetoDoses", 'server-dicom', 'SR')
                    json_data = {
                    'id': data[1],
                    'type': 'date_period',
                    'full_info': uid_vector
                    } 
                    logging.debug('got_send: '+str(json_data))
            
                elif data[-2] == 'name':
                    logging.debug('got_send uid')
                    uid_study_vector = AngioGet.study_get(data[0], '10.5.136.10', 4096, "projetoDoses", 'server-dicom', 'SR')                
                    json_data = {
                    'id': data[1],
                    'type': 'name',
                    'full_info': uid_study_vector
                    } 
                    logging.debug('got_send: '+str(json_data))
            
                elif data[-2] == 'uid':              
                    logging.debug('got_send angio')
                    angio_study_vector = AngioGet.angio_get_by_uid(data[0], '10.5.136.10', 4096, "projetoDoses", 'server-dicom', 'SR')
                    json_data = {
                    'id': data[1],
                    'type': 'uid',
                    'full_info': angio_study_vector
                    }    
                    logging.debug('got_send: '+str(json_data))
                else:
                    json_data = {}
            except:
                pass
            data = ('data='+json.dumps(json_data)+'&csrfmiddlewaretoken='+csrf).encode("utf-8")
            if local:
                response = urllib.request.Request('http://127.0.0.1:8000/comm/in/', data=data, method='POST')
            else:
                response = urllib.request.Request('http://esthevaov.pythonanywhere.com/comm/in/', data=data, method='POST')
            response_data = urllib.request.urlopen(response)
    
        time.sleep(1)
    

def worker_update():
    if local:
        response = urllib.request.urlopen('http://127.0.0.1:8000/comm/update')
    else:
        response = urllib.request.urlopen('http://esthevaov.pythonanywhere.com/comm/update')
    response_data = response.read()
    logging.debug('Update process started!')
    return True
    
    
def cancel_t(thread):
    logging.info('CANCELLED')
    thread.cancel() 
     
    
def main(argv):
    if len(argv) > 0:
        try:
            opts, args = getopt.getopt(argv, 'h', ['debug'])
        except getopt.GetoptError:
            print('with debug    -> $python script.py --debug')
            print('without debug -> $python script.py')
            sys.exit(2)
        for opt, arg in opts:
            if opt == '-h':
                print('with debug    -> $python script.py --debug')
                print('without debug -> $python script.py')
                sys.exit()
            elif opt in ('--debug'):
                logging.basicConfig(level=logging.DEBUG, format='%(asctime)s (%(threadName)-2s) %(message)s',)
    else:
        logging.basicConfig(level=logging.INFO)
            

    logging.info('Communication start...')
    if local:
        opener = login('http://127.0.0.1:8000/comm/login/', usernameV, passwordV)
    else:
        opener = login('http://esthevaov.pythonanywhere.com/comm/login/', usernameV, passwordV)

    stack = Stack()
    
    logging.info('Creating threads...')
    
    # Thread para receber informacao
    t_rec = threading.Thread(target=worker_receive, args=(stack,))
    t_rec.start()
    
    # Thread para mandar informacao
    t_send = threading.Thread(target=worker_send, args=(stack,))
    t_send.start()
    
    # Thread de cronograma de funcao de atualizacao
    t_sch = RepeatingTimer(1, 1, worker_update)
    t_sch.start()
    
    # Thread de cancelamento (ainda nao em uso)
    #t_can = threading.Timer(30, cancel_t, [t_sch])
    #t_can.start()
    
    logging.info('Worker threads created successfully!')
    
    
    main_thread = threading.currentThread()
    logging.info('Main threads created successfully!')    
    
    for t in threading.enumerate():
        if t is not main_thread:
            t.join()
    
    logging.info('END OF PROGRAM.')
    

if __name__ == "__main__":
    main(sys.argv[1:])