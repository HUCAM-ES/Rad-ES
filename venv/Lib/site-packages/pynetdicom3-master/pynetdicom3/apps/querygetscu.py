#!/usr/bin/env python

"""
    A getscu application.
"""

import argparse
import logging
import os
import socket
import sys
import time
import numpy
import pytesseract
import io


import matplotlib.pyplot as plt
from pydicom import uid, config

try:
    import Image
    print("IMPORTED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
except ImportError:
    from PIL import Image
    print("IMPORTED2!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")

from pydicom.dataset import Dataset, FileDataset
from pydicom.filewriter import write_file
from pydicom.uid import ExplicitVRLittleEndian, ImplicitVRLittleEndian, \
                        ExplicitVRBigEndian, UID

from pynetdicom3 import AE, StorageSOPClassList, QueryRetrieveSOPClassList
from pynetdicom3 import pynetdicom_uid_prefix
from pynetdicom3.pdu_primitives import SCP_SCU_RoleSelectionNegotiation

pytesseract.pytesseract.tesseract_cmd = 'C:\\Users\\Esthevao\\AppData\\Local\\Programs\\Python\\Python36-32\\Lib\\site-packages\\pytesseract'

logger = logging.Logger('getscu')
stream_logger = logging.StreamHandler()
formatter = logging.Formatter('%(levelname).1s: %(message)s')
stream_logger.setFormatter(formatter)
logger.addHandler(stream_logger)
logger.setLevel(logging.ERROR)


logger.setLevel(logging.DEBUG)
pynetdicom_logger = logging.getLogger('pynetdicom3')
pynetdicom_logger.setLevel(logging.DEBUG)

logger.debug('$getscu.py v{0!s} {1!s} $'.format('0.1.0', '2016-02-15'))
logger.debug('')

scu_classes = [x for x in QueryRetrieveSOPClassList]
scu_classes.extend(StorageSOPClassList)

ae = AE(ae_title="projetoDoses",
        port=0,
        scu_sop_class=scu_classes,
        scp_sop_class=[])


# Set the extended negotiation SCP/SCU role selection to allow us to receive
#   C-STORE requests for the supported SOP classes
ext_neg = []
for context in ae.presentation_contexts_scu:
    tmp = SCP_SCU_RoleSelectionNegotiation()
    tmp.sop_class_uid = context.AbstractSyntax
    tmp.scu_role = True
    tmp.scp_role = True

    ext_neg.append(tmp)
    

# Request association with remote
assoc = ae.associate('10.5.136.10', 4096, 'server-dicom', ext_neg=ext_neg)


#d.SeriesNumber = '*'
# d.Modality = 'CT'
# d.CTDIvol = 0
# d.BodyPartExamined = '*'
# d.SliceLocation = 0.0
# d.SOPClassUID = '*'
# d.ImageType = '*'
# d.ScanOptions = '*'
# d.PhotometricInterpretation = '*'
# d.Rows = 0
# d.BitsAllocated = 0
# d.BitsStored = 0
# d.HighBit = 0
# d.Exposure = 0
# d.ExposureTime = 0
# d.XRayTubeCurrent = 0
# d.ReferencedSOPInstanceUID = '1.2.392.200036.9116.2.5.1.37.2418728817.1457303754.378148'


#query_model = 'P'

def on_c_store(dataset):
    print('-------------------------------------------------------------------------------')
    #print(pytesseract.image_to_string(Image.open('test.png')))
    
    if(dataset.SOPClassUID == "XX-Ray Angiographic Image Storage"):
        
        
        if dataset.PixelRepresentation == 0:
            format_str = 'uint{}'.format(dataset.BitsAllocated)
        elif dataset.PixelRepresentation == 1:
            format_str = 'int{}'.format(dataset.BitsAllocated)
        else:
            format_str = 'bad_pixel_representation'
        try:
            numpy_dtype = numpy.dtype(format_str)
        except:
            pass
        
        numpy_dtype = numpy_dtype.newbyteorder('S')

        pixel_bytearray = dataset.PixelData

        pixel_array = numpy.fromstring(pixel_bytearray, dtype=numpy_dtype)
       
        pixel_array2 = dataset._reshape_pixel_array(pixel_array)
       
        print(len(pixel_array2))
        print(len(pixel_array2[0]))
        print(len(pixel_array2[0][0]))
       
        plt.imshow(pixel_array2[5], cmap=plt.cm.bone)
        plt.show()
        #image = Image.fromarray(pixel_array2)
        #image.show()
    
    #try:
        #print(pytesseract.image_to_string(img))
        #print(dataset.PixelData)
        #print(dataset)
        #print("hello")
        # print('SOP: ' + str(dataset.SOPInstanceUID))
        # print('Series Number: ' + str(dataset.SeriesNumber))
        # print('Image Type: ' + str(dataset.ImageType))
        # print('Series Description: ' + str(dataset.SeriesDescription))
        # print('Scan Options: ' + str(dataset.ScanOptions))
        # print('BodyPartExamined: ' + str(dataset.BodyPartExamined))
        # print('Exposure Time: ' + str(dataset.ExposureTime))
        # print('XRay Tube Current: ' + str(dataset.XRayTubeCurrent))
        # print('Exposure: ' + str(dataset.Exposure))
        # print('Instance Number:' + str(dataset.InstanceNumber))
        # print('CTDIvol: ' + str(dataset.CTDIvol))
        
    # except:
        # pass
        
    print('-------------------------------------------------------------------------------')   
    if(dataset.SOPClassUID == "X-Ray Radiation Dose SR Storage"):
        filename = 'SRS.{0!s}.dcm'.format(dataset.SOPInstanceUID)
        logger.info('Storing DICOM file: {0!s}'.format(filename))

        if os.path.exists(filename):
            logger.warning('DICOM file already exists, overwriting')

        logger.debug("pydicom::Dataset()")
        meta = Dataset()
        meta.MediaStorageSOPClassUID = dataset.SOPClassUID
        meta.MediaStorageSOPInstanceUID = dataset.SOPInstanceUID #'1.2.3'
        meta.ImplementationClassUID =  pynetdicom_uid_prefix #'1.2.3.4'

        logger.debug("pydicom::FileDataset()")
        ds = FileDataset(filename, {}, file_meta=meta, preamble=b"\0" * 128)
        ds.update(dataset)
        ds.is_little_endian = True
        ds.is_implicit_VR = True
        logger.debug("pydicom::save_as()")
        ds.save_as(filename, write_like_original=False)
    
    # print(dataset.PatientID)
    # """
    # Function replacing ApplicationEntity.on_store(). Called when a dataset is
    # received following a C-STORE. Write the received dataset to file

    # Parameters
    # ----------
    # dataset - pydicom.Dataset
        # The DICOM dataset sent via the C-STORE

    # Returns
    # -------
    # status : pynetdicom.sop_class.Status or int
        # A valid return status code, see PS3.4 Annex B.2.3 or the
        # StorageServiceClass implementation for the available statuses
    # """
    # mode_prefix = 'UN'
    # mode_prefixes = {'CT Image Storage' : 'CT',
                     # 'Enhanced CT Image Storage' : 'CTE',
                     # 'MR Image Storage' : 'MR',
                     # 'Enhanced MR Image Storage' : 'MRE',
                     # 'Positron Emission Tomography Image Storage' : 'PT',
                     # 'Enhanced PET Image Storage' : 'PTE',
                     # 'RT Image Storage' : 'RI',
                     # 'RT Dose Storage' : 'RD',
                     # 'RT Plan Storage' : 'RP',
                     # 'RT Structure Set Storage' : 'RS',
                     # 'Computed Radiography Image Storage' : 'CR',
                     # 'Ultrasound Image Storage' : 'US',
                     # 'Enhanced Ultrasound Image Storage' : 'USE',
                     # 'X-Ray Angiographic Image Storage' : 'XA',
                     # 'Enhanced XA Image Storage' : 'XAE',
                     # 'Nuclear Medicine Image Storage' : 'NM',
                     # 'Secondary Capture Image Storage' : 'SC'}

    # try:
        # mode_prefix = mode_prefixes[dataset.SOPClassUID.__str__()]
    # except:
        # pass

    # filename = '{0!s}.{1!s}'.format(mode_prefix, dataset.SOPInstanceUID)
    # logger.info('Storing DICOM file: {0!s}'.format(filename))

    # if os.path.exists(filename):
        # logger.warning('DICOM file already exists, overwriting')

    # meta = Dataset()
    # meta.MediaStorageSOPClassUID = dataset.SOPClassUID
    # meta.MediaStorageSOPInstanceUID = dataset.SOPInstanceUID
    # meta.ImplementationClassUID = pynetdicom_uid_prefix

    # ds = FileDataset(filename, {}, file_meta=meta, preamble=b"\0" * 128)
    # ds.update(dataset)
    # ds.is_little_endian = True
    # ds.is_implicit_VR = True
    # ds.save_as(filename)

    return 0x0000 # Success

ae.on_c_store = on_c_store

# Create query dataset

d = Dataset()
d.PatientName= 'ALVINO LEAL CAZAROTO' #'MARIA DAS GRACAS ALVES COSTA' #'GENNY FERES FAVERO' #'MARGARIDA DOS SANTOS OLIVEIRA'
d.StudyInstanceUID = '*'
d.GroupLength = 0
d.SeriesInstanceUID = '*'
d.SOPInstanceUID = '*'
d.BodyPartExamined = "*"
#d.InstanceNumber = 1
#d.SeriesNumber = 9000
d.Modality = 'SR'

# d.StudyInstanceUID = '1.2.392.200036.9116.2.5.1.37.2418728817.1457303667.507231'
# d.SeriesInstanceUID = '1.2.392.200036.9116.2.5.1.37.2418728817.1457304884.233164'
# d.SOPInstanceUID = '*' #'1.2.392.200036.9116.2.5.1.37.2418728817.1457304892.204109' 

query_model = 'P'

studyList =[]
seriesList =[]
instList =[]

# Send query
if assoc.is_established:

    d.QueryRetrieveLevel = "STUDY"
    response = assoc.send_c_find(d, query_model=query_model)
    for (status, dataset) in response:
        try:
            studyList.append(dataset.StudyInstanceUID)
        except:
            pass
        #logger.warning(dataset)
    time.sleep(0.1)
    if response is not None:
        for value in response:
            pass

   
    d.QueryRetrieveLevel = 'SERIES'
    for STIUID in studyList:
        auxList = []
        d.StudyInstanceUID = STIUID
        response = assoc.send_c_find(d, query_model=query_model)
        for (status, dataset) in response:
            try:
                auxList.append(dataset.SeriesInstanceUID)
            except:
                pass
            #logger.warning(dataset)
        time.sleep(0.1)
        if response is not None:
            for value in response:
                pass
        seriesList.append(auxList)
    d.QueryRetrieveLevel = 'IMAGE'
    for SEIUIDList in seriesList:
        aux2List = []
        for SEIUID in SEIUIDList:
            auxList = []
            d.StudyInstanceUID = '*'
            d.SeriesInstanceUID = SEIUID
            response = assoc.send_c_find(d, query_model=query_model)
            for (status, dataset) in response:
                try:
                    auxList.append(dataset.SOPInstanceUID)
                except:
                    pass
                #logger.warning(dataset)
            time.sleep(0.1)
            if response is not None:
                for value in response:
                    pass
            aux2List.append(auxList)
        instList.append(aux2List)
   
    print('------------------------INSTANCE LIST -----------------------------------')
    print(instList)
    print()
    for i in range(len(instList)):
        if len(instList[i]) != 0:
            for j in range(len(instList[i])):
                for k in range(len(instList[i][j])):
                #for k in range(1):
                    d.StudyInstanceUID = '*'
                    d.SeriesInstanceUID = '*'
                    print(i)
                    d.SOPInstanceUID = instList[i][j][k]
                    d.PatientName = '*'
                    response = assoc.send_c_get(d, query_model=query_model)
                    for (status, dataset) in response:
                        pass
                        #logger.warning(dataset)
                    time.sleep(0.1)
                    if response is not None:
                        for value in response:
                            pass
    assoc.release()

# done
ae.quit()
